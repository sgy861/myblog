# 实习问题记录

## 项目背景

开发了一个 AI 调用工具,主要功能是前端传入 SQL 语句,后端使用 AOP 进行安全校验并生成执行日志。在校验过程中会查询 SQL 白名单表以及对应表的字段配置。

---

## 功能模块

### 1. SQL 安全校验与日志记录 (AOP)

**核心类:** `AgentSqlAuditAspect`

**主要功能:**
- 拦截带有 `@AgentSqlAudit` 注解的方法
- 在 SQL 执行前进行静态安全检查
- 记录 SQL 执行日志(成功/失败)
- 抛出自定义异常并携带日志 ID

**安全校验策略:**

1. **第一层防线 - 表级白名单校验**
   - 使用 JSqlParser 解析 SQL 语句
   - 仅允许执行 SELECT 查询语句
   - 提取 SQL 中涉及的所有表名
   - 校验表是否在白名单中

2. **第二层防线 - 字段级白名单校验**
   - 当表配置了字段限制时启用
   - 严禁使用 `SELECT *`
   - 校验每个字段是否在允许的字段集合中
   - 支持函数表达式的递归检查(如 `COUNT(id)`, `MAX(age)`)

**关键代码逻辑:**
```java
// 表级校验
if (!allowedTables.contains(cleanTableName)) {
    throw new IllegalArgumentException("非法访问: 表 [" + cleanTableName + "] 未在白名单中");
}

// 字段级校验
if (!allowedColumns.contains(colName)) {
    throw new IllegalArgumentException("非法访问: 字段 [" + colName + "] 未授权或已禁用");
}
```

---

### 2. 白名单字段管理

**核心类:** `ColumnConfigServiceImpl`

**主要功能:**
- 同步 Doris 数据库的表字段到 MySQL 配置表
- 切换字段的启用/禁用状态
- 查询表的字段配置列表
- 刷新白名单缓存

---

## 遇到的问题与解决方案

### 问题 1: 跨数据源事务导致数据库切换失败

**问题描述:**

在同步白名单字段时,需要完成以下两个步骤:
1. 从 Doris 数据库查询表字段元数据
2. 将字段信息保存到 MySQL 的 `t_agent_column_config` 表

当把所有逻辑写在一个方法中,并在方法上添加 `@Transactional` 注解时,会导致数据库切换失败。

**原因分析:**

Spring 的 `@Transactional` 注解会在方法执行前开启事务,此时数据源已经绑定到某一个数据库(通常是默认的 MySQL)。即使方法内部使用了 `@DS("doris")` 注解尝试切换到 Doris 数据源,也会因为已经存在的事务上下文而无法切换,导致查询失败。

**错误代码示例:**

```java
@Transactional  // ❌ 事务开启后,数据源已绑定,无法切换
public void syncColumns(String tableName) {
    // Step 1: 查 Doris (切换失败,因为事务已开启)
    List<Map<String, Object>> dbColumns = metadataService.getTableColumns(tableName);
    
    // Step 2: 写 MySQL
    // ...保存逻辑
}
```

**解决方案:**

将跨数据源的逻辑拆分成两个方法:
1. 主方法不添加 `@Transactional`,负责调用 Doris 查询
2. 子方法添加 `@Transactional`,负责 MySQL 写入操作
3. 在类中注入自己(需要添加 `@Lazy` 防止循环依赖)
4. 通过 Spring 代理调用子方法,使事务注解生效

**正确代码:**

```java
@Service
public class ColumnConfigServiceImpl {
    
    // 注入自己,必须加 @Lazy 防止循环依赖
    @Lazy
    @Resource
    private ColumnConfigService selfService;
    
    // 主方法:不加事务注解
    public void syncColumns(String tableName) {
        // Step 1: 查 Doris (没有 MySQL 事务束缚,@DS("doris") 会生效)
        List<Map<String, Object>> dbColumns = metadataService.getTableColumns(tableName);
        
        if (dbColumns.isEmpty()) {
            throw new RuntimeException("Doris中不存在表 [" + tableName + "]");
        }
        
        // Step 2: 通过 Spring 代理调用,触发事务
        selfService.saveColumnsToMysql(tableName, dbColumns);
    }
    
    // 子方法:加事务注解,只操作 MySQL
    @Transactional(rollbackFor = Exception.class)
    public void saveColumnsToMysql(String tableName, List<Map<String, Object>> dbColumns) {
        // 1. 查当前配置表
        List<ColumnConfig> existList = columnMapper.selectList(
            new LambdaQueryWrapper<ColumnConfig>()
                .eq(ColumnConfig::getTableName, tableName)
        );
        
        // 2. 增量插入新字段
        // ...
        
        // 3. 刷新缓存
        if (addCount > 0) {
            whitelistManager.refreshWhitelist();
        }
    }
}
```

**关键点总结:**

1. **数据源切换时机:** `@Transactional` 会在方法开始时绑定数据源,之后无法切换
2. **方法拆分:** 跨数据源操作必须拆分到不同方法,各自控制事务边界
3. **Spring 代理:** 使用 `selfService` 调用而非 `this`,确保事务注解生效
4. **循环依赖:** 自注入时必须添加 `@Lazy` 注解

---

## 技术要点总结

### 1. AOP 使用
- `@Around` 环绕通知的使用
- `ProceedingJoinPoint` 获取方法参数和执行结果
- 异常统一处理与自定义异常抛出

### 2. SQL 解析
- 使用 JSqlParser 进行 SQL 静态分析
- `TablesNamesFinder` 提取表名
- `SelectItem` 遍历与字段校验
- 递归检查函数表达式

### 3. 多数据源管理
- `@DS` 注解进行数据源切换
- 事务与数据源的绑定关系
- 跨数据源操作的事务边界控制

### 4. 缓存刷新
- 白名单配置变更后及时刷新缓存
- 保证配置实时生效

---

## 后续优化方向

1. 支持更复杂的 SQL 查询(UNION、子查询等)
2. 完善字段级权限控制粒度
3. 添加更详细的审计日志
4. 性能优化:减少数据库查询次数
5. 增加单元测试覆盖率
